<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Custom Pong</title>
<style>
  body {
    margin: 0;
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    color: white;
    font-family: Arial, sans-serif;
    user-select: none;
  }
  #gameContainer {
    margin-top: 10px;
    position: relative;
  }
  canvas {
    background: black;
    display: block;
    border: 2px solid white; /* white outline around arena */
  }
  #controls {
    margin-top: 10px;
    display: flex;
    gap: 10px;
  }
  .btn {
    padding: 6px 14px;
    background: blue;
    color: white;
    border: 2px solid white;
    cursor: pointer;
    font-weight: bold;
  }
  .btn.active {
    background: yellow;
    color: black;
  }
</style>
</head>
<body>
<h2>Custom Pong</h2>
<div id="controls">
  <button id="slowBtn" class="btn">Slow</button>
  <button id="pauseBtn" class="btn">Pause</button>
  <button id="resetBtn" class="btn">Reset</button>
</div>
<div id="gameContainer">
  <canvas id="game" width="800" height="500"></canvas>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const W = canvas.width;
const H = canvas.height;

// Arena and layout
const midX = W / 2;
const paddleWidth = 12;
const paddleHeight = 80;
const paddleOffset = 5; // snug to wall
const ballRadius = 8;

// Speeds
const BASE_SPEED = 4;
const SLOW_SPEED = 2;
const FAST_SPEED = 8; // power shot speed
let currentSpeed = BASE_SPEED;

// Game state
let leftScore = 0;
let rightScore = 0;

let ball = {
  x: midX,
  y: H / 2,
  vx: BASE_SPEED,
  vy: 1.5, // slight angle
  speed: BASE_SPEED,
  isPower: false
};

let leftPaddle = {
  x: paddleOffset,
  y: H / 2 - paddleHeight / 2,
  vy: 6
};

let rightPaddle = {
  x: W - paddleOffset - paddleWidth,
  y: H / 2 - paddleHeight / 2,
  vy: 6,
  targetY: H / 2,
  willHit: true
};

// Trail
const trail = [];
const TRAIL_MAX_POINTS = 25;
const TRAIL_MAX_DIST = 40; // ~2cm-ish visual distance

// Flashes
let leftFlash = null;  // {color, until}
let rightFlash = null;

// Control flags
let paused = false;
let slowMode = false;

// Buttons
const slowBtn = document.getElementById('slowBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');

slowBtn.onclick = () => {
  slowMode = !slowMode;
  slowBtn.classList.toggle('active', slowMode);
  updateBallSpeed();
};

pauseBtn.onclick = () => {
  paused = !paused;
  pauseBtn.classList.toggle('active', paused);
};

resetBtn.onclick = () => {
  leftScore = 0;
  rightScore = 0;
  resetBall(true);
  resetBtn.classList.add('active');
  setTimeout(() => resetBtn.classList.remove('active'), 150);
};

function updateBallSpeed() {
  if (ball.isPower) {
    ball.speed = FAST_SPEED;
  } else {
    ball.speed = slowMode ? SLOW_SPEED : BASE_SPEED;
  }
  const dir = Math.hypot(ball.vx, ball.vy) || 1;
  ball.vx = (ball.vx / dir) * ball.speed;
  ball.vy = (ball.vy / dir) * ball.speed;
}

// Keyboard control for left paddle (W/S or ArrowUp/ArrowDown)
const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

function handleLeftPaddleInput() {
  if (keys['w'] || keys['ArrowUp']) {
    leftPaddle.y -= leftPaddle.vy;
  }
  if (keys['s'] || keys['ArrowDown']) {
    leftPaddle.y += leftPaddle.vy;
  }
  clampPaddle(leftPaddle);
}

function clampPaddle(p) {
  if (p.y < 0) p.y = 0;
  if (p.y + paddleHeight > H) p.y = H - paddleHeight;
}

// AI logic: 60% hit, 40% miss, no jitter
function updateAI() {
  // Only update decision when ball is moving toward right
  if (ball.vx > 0 && ball.x > midX - 10) {
    if (Math.random() < 0.6) {
      rightPaddle.willHit = true;
      rightPaddle.targetY = ball.y - paddleHeight / 2;
    } else {
      rightPaddle.willHit = false;
      const offset = (Math.random() * 80 - 40); // near but wrong
      rightPaddle.targetY = ball.y - paddleHeight / 2 + offset;
    }
  }

  // Move smoothly toward targetY
  const centerY = rightPaddle.y;
  if (rightPaddle.targetY < centerY) {
    rightPaddle.y -= rightPaddle.vy;
  } else if (rightPaddle.targetY > centerY) {
    rightPaddle.y += rightPaddle.vy;
  }
  clampPaddle(rightPaddle);
}

// Ball reset: goes from red line toward side that should receive it
function resetBall(toRight) {
  ball.x = midX;
  ball.y = H / 2;
  ball.isPower = false;
  currentSpeed = slowMode ? SLOW_SPEED : BASE_SPEED;
  ball.speed = currentSpeed;
  const angle = 0.3; // slight angle
  ball.vx = (toRight ? 1 : -1) * ball.speed * Math.cos(angle);
  ball.vy = ball.speed * Math.sin(angle);
  trail.length = 0;
}

// Flash helpers
function setFlash(side, color) {
  const until = performance.now() + 1000;
  if (side === 'left') {
    leftFlash = { color, until };
  } else {
    rightFlash = { color, until };
  }
}

// Collision detection
function rectCircleCollide(px, py, pw, ph, cx, cy, cr) {
  const testX = Math.max(px, Math.min(cx, px + pw));
  const testY = Math.max(py, Math.min(cy, py + ph));
  const distX = cx - testX;
  const distY = cy - testY;
  return (distX * distX + distY * distY) <= cr * cr;
}

function update() {
  if (paused) return;

  handleLeftPaddleInput();
  updateAI();

  // Move ball
  ball.x += ball.vx;
  ball.y += ball.vy;

  // Add to trail
  trail.push({ x: ball.x, y: ball.y, isPower: ball.isPower });
  if (trail.length > TRAIL_MAX_POINTS) trail.shift();

  // Top/bottom walls
  if (ball.y - ballRadius < 0) {
    ball.y = ballRadius;
    ball.vy *= -1;
  }
  if (ball.y + ballRadius > H) {
    ball.y = H - ballRadius;
    ball.vy *= -1;
  }

  // Left paddle collision
  if (rectCircleCollide(leftPaddle.x, leftPaddle.y, paddleWidth, paddleHeight, ball.x, ball.y, ballRadius)) {
    ball.x = leftPaddle.x + paddleWidth + ballRadius;
    ball.vx = Math.abs(ball.vx);
    leftScore++;
    setFlash('left', 'green');
    maybePowerShot();
  }

  // Right paddle collision
  if (rectCircleCollide(rightPaddle.x, rightPaddle.y, paddleWidth, paddleHeight, ball.x, ball.y, ballRadius)) {
    ball.x = rightPaddle.x - ballRadius;
    ball.vx = -Math.abs(ball.vx);
    rightScore++;
    setFlash('right', 'green');
    maybePowerShot();
  }

  // Out of bounds left
  if (ball.x + ballRadius < 0) {
    setFlash('left', 'red'); // left missed
    resetBall(true); // send toward right
  }

  // Out of bounds right
  if (ball.x - ballRadius > W) {
    setFlash('right', 'red'); // right missed
    resetBall(false); // send toward left
  }

  // Clear expired flashes
  const now = performance.now();
  if (leftFlash && now > leftFlash.until) leftFlash = null;
  if (rightFlash && now > rightFlash.until) rightFlash = null;
}

function maybePowerShot() {
  if (Math.random() < 0.3) {
    ball.isPower = true;
  } else {
    ball.isPower = false;
  }
  updateBallSpeed();
}

// Drawing
function drawArena() {
  // Background flashes
  if (leftFlash) {
    ctx.fillStyle = leftFlash.color;
    ctx.fillRect(0, 0, midX, H);
  } else {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, midX, H);
  }

  if (rightFlash) {
    ctx.fillStyle = rightFlash.color;
    ctx.fillRect(midX, 0, midX, H);
  } else {
    ctx.fillStyle = 'black';
    ctx.fillRect(midX, 0, midX, H);
  }

  // White outline (border already from CSS, but reinforce)
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 2;
  ctx.strokeRect(0, 0, W, H);

  // Red center line
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(midX, 0);
  ctx.lineTo(midX, H);
  ctx.stroke();

  // Corner right triangles
  ctx.fillStyle = 'white';
  const triSize = 20;
  // Top-left
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(triSize, 0);
  ctx.lineTo(0, triSize);
  ctx.closePath();
  ctx.fill();
  // Top-right
  ctx.beginPath();
  ctx.moveTo(W, 0);
  ctx.lineTo(W - triSize, 0);
  ctx.lineTo(W, triSize);
  ctx.closePath();
  ctx.fill();
  // Bottom-left
  ctx.beginPath();
  ctx.moveTo(0, H);
  ctx.lineTo(triSize, H);
  ctx.lineTo(0, H - triSize);
  ctx.closePath();
  ctx.fill();
  // Bottom-right
  ctx.beginPath();
  ctx.moveTo(W, H);
  ctx.lineTo(W - triSize, H);
  ctx.lineTo(W, H - triSize);
  ctx.closePath();
  ctx.fill();
}

function drawPaddles() {
  ctx.fillStyle = 'white';
  ctx.fillRect(leftPaddle.x, leftPaddle.y, paddleWidth, paddleHeight);
  ctx.fillRect(rightPaddle.x, rightPaddle.y, paddleWidth, paddleHeight);
}

function drawTrail() {
  for (let i = 0; i < trail.length; i++) {
    const p = trail[i];
    const dx = ball.x - p.x;
    const dy = ball.y - p.y;
    const dist = Math.hypot(dx, dy);
    if (dist > TRAIL_MAX_DIST) continue;

    const alpha = 1 - dist / TRAIL_MAX_DIST;
    if (p.isPower) {
      // Fire trail
      ctx.fillStyle = `rgba(255,140,0,${alpha})`;
    } else {
      // Metallic purple trail
      ctx.fillStyle = `rgba(147,112,219,${alpha})`;
    }
    ctx.beginPath();
    ctx.arc(p.x, p.y, ballRadius * 0.9, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawBall() {
  if (ball.isPower) {
    ctx.fillStyle = 'orange';
  } else {
    ctx.fillStyle = 'blue';
  }
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
  ctx.fill();
}

function drawScores() {
  ctx.fillStyle = 'white';
  ctx.font = '24px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';

  // Left score: left side of red line, top middle of that half
  ctx.fillText(leftScore, midX / 2, 10);

  // Right score: right side of red line, top middle of that half
  ctx.fillText(rightScore, midX + midX / 2, 10);
}

function loop() {
  update();
  drawArena();
  drawTrail();
  drawPaddles();
  drawBall();
  drawScores();
  requestAnimationFrame(loop);
}

// Initial ball direction: toward middle-right at slight angle
resetBall(true);
loop();
</script>
</body>
</html>
